<?php

namespace App\Models;

use App\Notifications\PointReceived;
use App\Notifications\PointReceivedFromDeveloper;
use App\Notifications\ResetPassword;
use App\Notifications\VerifyEmail;
use App\Traits\HasBackgroundPhoto;
use Auth;
use Carbon\Carbon;
use Illuminate\Auth\MustVerifyEmail;
use Illuminate\Auth\Passwords\CanResetPassword;
use Illuminate\Database\Eloquent\Builder;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;
use Laravel\Cashier\Billable;
use Laravel\Fortify\TwoFactorAuthenticatable;
use Laravel\Jetstream\HasProfilePhoto;
use Laravel\Jetstream\HasTeams;
use Laravel\Jetstream\Jetstream;
use Laravel\Sanctum\HasApiTokens;

// tsaken out when trying to remove the personal teams

//use \App\Actions\Jetstream\HasTeams;

class User extends Authenticatable
{
    use HasApiTokens;
    use HasFactory;
    use HasProfilePhoto;
    use HasBackgroundPhoto;
    use HasTeams;
    use Notifiable;
    use TwoFactorAuthenticatable;
    use Billable;
    use MustVerifyEmail;
    use CanResetPassword;

    /**
     * The attributes that are mass assignable.
     *
     * @var array
     */
    protected $fillable = [
        'first_name',
        'last_name',
        'name',
        'initials',
        'email',
        'password',
        'company_id',
        'level',
        'role',
        'birthday',
        'anniversary',
        'currency',
    ];

    /**
     * The attributes that should be hidden for arrays.
     *
     * @var array
     */
    protected $hidden = [
        'password',
        'remember_token',
        'two_factor_recovery_codes',
        'two_factor_secret',
    ];

    /**
     * The attributes that should be cast to native types.
     *
     * @var array
     */
    protected $casts = [
        'email_verified_at' => 'datetime',
        'emails_opt_in' => 'boolean',
    ];

    protected $dates = ['birthday', 'anniversary'];

    /**
     * The accessors to append to the model's array form.
     *
     * @var array
     */
    protected $appends = ['profile_photo_url', 'background_photo_url'];

    protected static function boot()
    {
        static::deleted(function ($user) {
            //remove user related data from other tables

            //            DB::table('card_user')->where('user_id', $user->id)->delete();
            //            DB::table('team_user')->where('user_id', $user->id)->delete();
            //
            //            Card::where('creator_id', $user->id)->delete();
            //            Point::where(function ($q) use ($user) {
            //                $q->where('from_id', $user->id)->orWhere('user_id', $user->id);
            //            })->delete();
        });

        parent::boot(); // TODO: Change the autogenerated stub
    }

    public function sendEmailVerificationNotification()
    {
        $this->notify(new VerifyEmail());
    }

    public function sendPasswordResetNotification($token)
    {
        $this->notify(new ResetPassword($token));
    }

    //    public function setNameAttribute()
    //    {
    //        $this->attributes['name'] = collect([$this->first_name, $this->last_name])->filter()->implode(' ');
    //    }

    public function givePoints(User $user, $amount, $message, $isSuper = false)
    {
        $point = new Point();
        $point->amount = $amount;
        $point->message = $message;
        $point->type = $isSuper ? Point::TYPE_SUPER : Point::TYPE_STANDARD;

        if (Auth::user()->points_to_give < $amount) {
            return 'Not enough '.getReplacedWordOfKudos();
        }

        $user->points += intval($amount);
        Auth::user()->points_to_give -= intval($amount);

        $point->giver()->associate(Auth::user());
        $point->reciever()->associate($user);

        $user->save();
        Auth::user()->save();
        $point->save();

        //adding the transaction logic for "expiration"
        //gets the latest kudosToGiveTransaction that is not expired
        $ts = auth()
            ->user()
            ->kudosToGiveTransactions->where('expired', '=', 0)
            ->where('amount_remaining', '>', 0)
            ->sortBy('expiration');

        $a = $point->amount;
        foreach ($ts as $t) {
            $less = min($t->amount_remaining, $a);
            $t->amount_remaining -= $less;
            $a -= $less;
            $t->points_string .= (string) $point->id.', ';
            if ($less > 0) {
                $t->save();
            }
        }

        $user->notify(new PointReceived($point));

        return $point;
    }

    public function givePointsFromDeveloper(
        User $user,
        $amount,
        $message,
        $isSuper = false
    ) {
        $point = new Point();
        $point->amount = $amount;
        $point->message = $message;
        $point->type = $isSuper ? Point::TYPE_SUPER : Point::TYPE_STANDARD;

        $user->points += intval($amount);

        $point->giver()->associate(Auth::user());
        $point->reciever()->associate($user);

        $user->save();
        auth()
            ->user()
            ->save();
        $point->save();

        $point
            ->forceFill([
                'hidden' => 1,
                'hidden_by' => auth()->id(),
            ])
            ->save();

        $user->notify(new PointReceivedFromDeveloper($point));

        return $point;
    }

    public function givers()
    {
        return $this->hasMany(Point::class, 'from_id')->visible();
    }

    public function recentSentPoint()
    {
        return $this->hasOne(Point::class, 'from_id')
            ->visible()
            ->latest();
    }

    public function private_giver_points()
    {
        return $this->hasMany(Point::class, 'from_id')->private();
    }

    public function recievers()
    {
        return $this->hasMany(Point::class, 'user_id')->visible();
    }

    public function productTour()
    {
        return $this->hasOne(ProductTour::class, 'user_id');
    }

    public function invitation()
    {
        return $this->hasOne(UserInvitation::class, 'email', 'email')->latest();
    }

    public function setProductTour()
    {
        if (! $this->productTour) {
            $pt = new ProductTour();
            $pt->user()->associate($this);
            $pt->company()->associate($this->company);
            $pt->save();

            return $pt;
        }

        return $this->productTour;
    }

    public function private_receiver_points()
    {
        return $this->hasMany(Point::class, 'user_id')->private();
    }

    public function kudosToGiveTransactions()
    {
        return $this->hasMany(KudosToGiveTransaction::class, 'user_id');
    }

    public function grab_company_points($type = 'public')
    {
        //$team_points = $this->teams->pluck('users')->flatten()->unique()->pluck('recievers')->flatten()->unique(); // this only showed team associated points
        $users = $this->company->users->flatten()->unique();

        if ($type == 'public') {
            $users = $users->pluck('recievers');
        } else {
            $users = $users->pluck('private_receiver_points');
        }

        return $users->flatten()->unique();
    }

    public function grab_associated_points($type = 'public')
    {
        //$team_points = $this->teams->pluck('users')->flatten()->unique()->pluck('recievers')->flatten()->unique(); // this only showed team associated points

        if ($type == 'public') {
            $to = $this->company->users
                ->flatten()
                ->unique()
                ->pluck('recievers')
                ->flatten()
                ->unique()
                ->where('user_id', $this->id);
            $from = $this->company->users
                ->flatten()
                ->unique()
                ->pluck('recievers')
                ->flatten()
                ->unique()
                ->where('from_id', $this->id);
        } else {
            $to = $this->company->users
                ->flatten()
                ->unique()
                ->pluck('private_receiver_points')
                ->flatten()
                ->unique()
                ->where('user_id', $this->id);
            $from = $this->company->users
                ->flatten()
                ->unique()
                ->pluck('private_receiver_points')
                ->flatten()
                ->unique()
                ->where('from_id', $this->id);
        }

        return collect([$to, $from])
            ->flatten()
            ->unique();
    }

    /// overwrite to remove personal teams ////

    public function grab_team_points(Team $team, $type = 'public')
    {
        if ($type == 'public') {
            return $team->users
                ->pluck('recievers')
                ->flatten()
                ->unique();
        } else {
            return $team->users
                ->pluck('private_receiver_points')
                ->flatten()
                ->unique();
        }
    }

    public function hasTeams()
    {
        return $this->allTeams()->isNotEmpty();
    }

    public function allTeams()
    {
        return $this->ownedTeams->merge($this->teams)->sortBy('name');
    }

    /**
     * Determine if the given team is the current team.
     *
     * @param mixed $team
     * @return bool
     */
    public function isCurrentTeam($team)
    {
        if (! $this->allTeams()->count()) {
            return false;
        }

        return $team->id === data_get($this->currentTeam, 'id');
    }

    /**
     * Get the current team of the user's context.
     */
    public function currentTeam()
    {
        if (is_null($this->current_team_id) && $this->id) {
            $this->switchTeam($this->allTeams()->first());
        }

        return $this->belongsTo(Jetstream::teamModel(), 'current_team_id');
    }

    public function ownedTeams()
    {
        return $this->hasMany(Jetstream::teamModel());
    }

    public function hasTeamRole($team, string $role)
    {
        return $this->belongsToTeam($team) &&
            optional(
                Jetstream::findRole(
                    $team->users->where('id', $this->id)->first()->membership
                        ->role
                )
            )->key === $role;
    }

    public function redemptions()
    {
        return $this->hasMany(Redemption::class);
    }

    public function company()
    {
        return $this->belongsTo(Company::class);
    }

    public function cards()
    {
        return $this->belongsToMany(Card::class)->withPivot(
            'active',
            'has_published',
            'notified'
        );
    }

    public function meetingConfig()
    {
        return $this->hasOne(MeetingConfig::class);
    }

    public function user1Meetings()
    {
        return $this->hasMany(Meeting::class, 'user1_id');
    }

    public function user2Meetings()
    {
        return $this->hasMany(Meeting::class, 'user2_id');
    }

    public function hasMetWith(User $user)
    {
        return $this->meetings()
            ->pluck('user1')
            ->merge($this->meetings()->pluck('user2'))
            ->unique()
            ->where('id', $user->id)
            ->isNotEmpty();
    }

    public function meetings()
    {
        return $this->user1Meetings->merge($this->user2Meetings);
    }

    public function prevMeetings()
    {
        //note I think these are people not meetings... the people they met with already
        return $this->meetings()
            ->pluck('user1')
            ->merge($this->meetings()->pluck('user2'))
            ->where('id', '!=', $this->id);
    }

    public function scopeHasBirthday(Builder $query, $afterDays = 0)
    {
        $birthdayDate = now()->addDays($afterDays);

        return $query->where(function ($q) use ($birthdayDate) {
            $q->whereMonth('birthday', '=', $birthdayDate->month)->whereDay(
                'birthday',
                '=',
                $birthdayDate->day
            );
        });
    }

    public function scopeHasWorkAnniversary(Builder $query, $afterDays = 0)
    {
        $workAnniversaryDate = now()->addDays($afterDays);

        return $query->where(function ($q) use ($workAnniversaryDate) {
            $q->whereMonth('anniversary', '=', $workAnniversaryDate->month)
                ->whereDay('anniversary', '=', $workAnniversaryDate->day)
                ->whereYear('anniversary', '<', $workAnniversaryDate->year);
        });
    }

    public function scopeHasUpcomingSpecialDay(
        $query,
        $specialDay = '',
        $days = 7
    ) {
        return //            ->orderByRaw('CASE WHEN (anniversary + INTERVAL (YEAR(CURRENT_DATE) - YEAR(anniversary)) YEAR) >= CURRENT_DATE
            //	THEN (anniversary + INTERVAL (YEAR(CURRENT_DATE) - YEAR(anniversary)) YEAR)
            //	ELSE (anniversary + INTERVAL (YEAR(CURRENT_DATE) - YEAR(anniversary)) + 1 YEAR) END')
            $query->where(function ($q) {
                $q->whereNotNull('birthday')->orWhereNotNull('anniversary');
            })
                ->orderByRaw('CASE WHEN (birthday + INTERVAL (YEAR(CURRENT_DATE) - YEAR(birthday)) YEAR) >= CURRENT_DATE
	THEN (birthday + INTERVAL (YEAR(CURRENT_DATE) - YEAR(birthday)) YEAR)
	ELSE (birthday + INTERVAL (YEAR(CURRENT_DATE) - YEAR(birthday)) + 1 YEAR) END');

        $from = \Carbon\Carbon::today();
        $to = \Carbon\Carbon::today()->addDays($days);

        if ($specialDay) {
            $query->where(function ($q) use ($specialDay, $from, $to) {
                $q->whereMonth($specialDay, '>=', $from->month)
                    ->whereMonth($specialDay, '<=', $to->month)
                    ->whereDay($specialDay, '>=', $from->day)
                    ->whereDay($specialDay, '<=', $to->day);
            });
        } else {
            $query
                ->where(function ($q) {
                    $q->hasUpcomingSpecialDay(
                        'birthday'
                    )->orHasUpcomingSpecialDay('anniversary');
                })
                ->orderByRaw(
                    'birthday is null, anniversary is null, DAYOFYEAR(birthday), DAYOFYEAR(anniversary)'
                );
        }

        return $query;
    }

    public function scopeOrHasUpcomingSpecialDay($query, $specialDay, $days = 7)
    {
        $from = \Carbon\Carbon::today();
        $to = \Carbon\Carbon::today()->addDays($days);

        return $query->orWhere(function ($q) use ($specialDay, $from, $to) {
            $q->whereMonth($specialDay, '>=', $from->month)
                ->whereMonth($specialDay, '<=', $to->month)
                ->whereDay($specialDay, '>=', $from->day)
                ->whereDay($specialDay, '<=', $to->day);
        });
    }

    public function getHasUpcomingBirthdayAttribute()
    {
        return (bool) $this->birthday;
        //            && $this->birthday->month >= now()->startOfDay()->month
        //            && $this->birthday->month <= now()->addDays(7)->endOfDay()->month
        //            && $this->birthday->day >= now()->startOfDay()->day
        //            && $this->birthday->day <= now()->addDays(7)->endOfDay()->day;
    }

    public function getHasUpcomingAnniversaryAttribute()
    {
        return (bool) $this->anniversary;
        //            && $this->anniversary->month >= now()->startOfDay()->month
        //            && $this->anniversary->month <= now()->addDays(7)->endOfDay()->month
        //            && $this->anniversary->day >= now()->startOfDay()->day
        //            && $this->anniversary->day <= now()->addDays(7)->endOfDay()->day;
    }

    public function scopeActive($query)
    {
        return $query->where('active', 1);
    }

    public function scopeTimezone($query, $timezone)
    {
        return $query->where('timezone', $timezone);
    }

    public function scopeEmailOptIn($query)
    {
        return $query->where('emails_opt_in', 1);
    }

    public function scopeHasJoinedSystem($query, $beforeDays = null)
    {
        return $query->where('is_ghost', false)
            ->when($beforeDays, function ($q) use ($beforeDays) {
                $q->where('created_at', '<=', now()->subDays($beforeDays));
            });
    }

    public function scopeGhostUser($query)
    {
        return $query->where('is_ghost', true);
    }

    public function scopeCompany($query, $companyId)
    {
        return $query->where('company_id', $companyId);
    }

    public function routeNotificationForSlack($notification)
    {
        //this code will be executed from job - so Auth::user() wont be available here.
        if (! $this->company->enable_slack) {
            return;
        }

        return $this->company->slack_webhook ?? '';
    }

    public function routeNotificationForMicrosoftTeams($notification)
    {
        if (! $this->company->enable_microsoft_teams) {
            return;
        }

        return $this->company->microsoft_teams_webhook ?? '';
    }

    public function transactions()
    {
        return $this->hasMany(Transaction::class);
    }

    public function whitelabel_company()
    {
        return $this->hasOne(
            WhitelabelCompany::class,
            'company_id',
            'company_id'
        );
    }

    public function getNameWithoutPrefixAttribute()
    {
        return name_without_prefix($this->name);
    }

    public function get_level_points()
    {
        if (! $this->company) {
            return 'no company';
        }
        if (! $this->active) {
            return 'not active '.(string) $this->active;
        }
        $c = $this->company;
        if ($this->level == 1) {
            $level = $c->level_1_points_to_give;
        }
        if ($this->level == 2) {
            $level = $c->level_2_points_to_give;
        }
        if ($this->level == 3) {
            $level = $c->level_3_points_to_give;
        }
        if ($this->level == 4) {
            $level = $c->level_4_points_to_give;
        }
        if ($this->level == 5) {
            $level = $c->level_5_points_to_give;
        }

        return $level;
    }

    public function getFormattedRecentKudosSentAtAttribute()
    {
        return defaultDateFormat(
            data_get($this->recentSentPoint, 'created_at')
        );
    }

    public function getFormattedLastLoginAtAttribute()
    {
        return defaultDateFormat($this->last_login);
    }

    protected function defaultProfilePhotoUrl()
    {
        $initial = $this->initials;

        if (empty($initial) || is_null($initial)) {
            $initial = $this->name_without_prefix;
        }

        return "https://ui-avatars.com/api/?name=$initial&color=7F9CF5&background=EBF4FF";
    }

    public function getFullNameAttribute()
    {
        return trim($this->first_name.' '.$this->last_name);
    }

    public function getBirthdayDateAttribute()
    {
        if ($this->birthday) {
            return str_pad(Carbon::parse($this->birthday)->format('d'), 2, '0');
        }

        return null;
    }

    public function getBirthdayMonthAttribute()
    {
        if ($this->birthday) {
            return str_pad(Carbon::parse($this->birthday)->format('m'), 2, '0');
        }

        return null;
    }

    public function getFormattedAnniversaryAttribute()
    {
        if($this->anniversary) {
            return $this->anniversary->format('Y-m-d');
        }

        return null;
    }
}
